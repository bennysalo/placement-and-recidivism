---
title: "Combined notebooks. Analyses for 'The practices of open prison and conditional release and their relation to recidivism rates'"
output: html_notebook
---

Load needed packages

```{r}
library(tidyverse)
library(stringr)
library(MatchIt)
library(ggthemes)
library(gridExtra)
sessionInfo()
```

Import dataset 'FinPrisonMales'. This version of the data includes only males. Data is not publicly available. Check https://osf.io/e9dzf/ for a description of the data, including inclusion and exclusion criteria and summary statistics. (This description will be uploaded at a later date - it is not yet available as of 2018-02-19.)

```{r}
rm(list = ls())
FinPrisonMales <- 
  readRDS("C:/Users/benny_000/Dropbox/AAAKTUELLT/FinPrisonData/FinPrisonMales.rds")
```


Create new variables. MatchIt needs dichotomous response variables. 

```{r}
FinPrisonMales <-
  FinPrisonMales %>%
  mutate(open01 = ifelse(openPrison == "open_prison", 1, 0),
         cond01 = ifelse(conditionalReleaseGranted == "cr_granted", 1, 0),
         superv01 = ifelse(supervisedParole == "supervised parole", 1, 0))
         # oc_violent = ifelse(o_assault == 0 & o_homicide == 0, 0, 1),
         # newOc_violent = ifelse(newO_assault == 0 & newO_homicide == 0, 0, 1))
```


Exclude individuals who comitted a crime during the sentence. This is the simplest way to handle the issue that we do not know when the crime was committed or when it was uncovered.

```{r}
included_sample <-
  FinPrisonMales %>% 
  filter(crimeDuringSentence == "No records of crime")

rm(FinPrisonMales)
```


Also, exclude individuals with suspended conditional release. This is the easiest way to handle the confounding that individuals granted conditional release from open prison may have been placed in closed prison if the conditional release was revoked.


```{r}
included_sample <-
  included_sample %>% 
  filter(conditionalReleaseOutcome != "Cancelled conditional release")

```

This leaves us with the following breakdown of individuals.
```{r}
table(included_sample$openPrison, included_sample$conditionalReleaseOutcome)
```

Further we seperate those with their parole supervised and those without supervision.

```{r}
table(included_sample$supervisedParole, included_sample$conditionalReleaseOutcome, included_sample$openPrison)
```

The smallest groups (individuals placed in closed prison and not granted conditional release) will not be examined further. That leaves us with the possiblity to examine 
- the effect of placement among those not granted conditional release
- the effect of conditional release among those placed in open prison at the end of their sentence.



# Define sets of predictors

```{r}
offence_variables <- 
  str_subset(names(included_sample), "^o_")

static_preds <- 
   c("ageFirstSentence_mr", "ageFirst_missing", "ageAtRelease", 
     "ps_escapeHistory", "ps_prisonTerms_mr", "ps_comServiceTerms_mr", 
     "ps_remandTerms_mr", "ps_defaultTerms_mr", "ps_info_missing", 
     offence_variables)


rita_factors <- 
   c("economy_problems", "alcohol_problems", "resistance_change", 
     "drug_related_probl", "aggressiveness", "employment_probl") 


all_predictors <- c(static_preds, rita_factors)

```


Use these propensity scores as covariate in later glm analyses.

To estimate these propensity scores we include the other exactly matched variables.

```{r}
propensity_formula_open <- as.formula(paste("open01 ~ (", paste(all_predictors, collapse = " + "),
                                            ") * (conditionalReleaseGranted + supervisedParole)"))

propensity_formula_cond <- as.formula(paste("cond01 ~ (", paste(all_predictors, collapse = " + "),
                                            ") * (openPrison + supervisedParole)"))

propensity_formula_superv <- as.formula(paste("superv01 ~ (", paste(all_predictors, collapse = " + "),
                                            ") * (openPrison + conditionalReleaseGranted)"))

```

Use above formulas in logistic regression with the three conditions as outcomes.

```{r}
propensity_model_open <- glm(propensity_formula_open, family = binomial, data = included_sample)

propensity_model_cond <- glm(propensity_formula_cond, family = binomial, data = included_sample)

propensity_model_superv <- glm(propensity_formula_superv, family = binomial, data = included_sample)

```

Estimate propesity scores from the models above. Logit scores will be used as predictor in logistic regression. Probabilities will be used in graphs.

```{r}
included_sample <- included_sample %>% 
  mutate(propensity_open_logit   = predict(propensity_model_open),
         propensity_open_prob    = predict(propensity_model_open, type = "response"),
         propensity_cond_logit   = predict(propensity_model_cond),
         propensity_cond_prob    = predict(propensity_model_cond, type = "response"),
         propensity_superv_logit = predict(propensity_model_superv),
         propensity_superv_prob  = predict(propensity_model_superv, type = "response"))

```

Create subgroups


op = Open Placement
cr = Conditional Release
ps = Parole Supervised

0 = no, 1 = yes

```{r}
# Subgroups for examining effect of open prison
subset_cr0_ps0<-
  included_sample %>% 
  filter(conditionalReleaseGranted == "cr_not_granted" & supervisedParole == "no supervision")

subset_cr0_ps1 <-
  included_sample %>% 
  filter(conditionalReleaseGranted == "cr_not_granted" & supervisedParole == "supervised parole")

# Subgroups for examining effect of conditional relase
subset_op1_ps0  <-
  included_sample %>% 
  filter(openPrison == "open_prison" & supervisedParole == "no supervision")

subset_op1_ps1 <- 
  included_sample %>% 
  filter(openPrison == "open_prison" & supervisedParole == "supervised parole")


```


Key for abbreviations:

op = Open Placement
cr = Conditional Release
ps = Parole Supervised

0 = no, 1 = yes




Write a function for matching. This function takes the following arguments:
+ 'subset_data' - A data frame. The subset previously generated that only includes individuals who have gotten the same treatment except for the effect variable. 
+ 'effect_variable' - A character string. The name of the variable that constitutes the independent variable in later analysis. The matching should thus produce two groups that are blananced on every covariate except this variable.
+ 'blancing_variables' - A vector of character stings. The names of all the variables that serve as covariates. The default is a previously defined vector 'all_predictors'.


```{r}

my_matching <- function(subset_data, effect_variable, balancing_variables = all_predictors, ...) {
  require(MatchIt)
  
  # Intitate a list of results that will be returned
   out <- list(effect_variable = effect_variable, data = subset_data, match = NA)

  # Write the formulas that will be needed
  # Matching formulas. Here the other exactly matched variables are not included as predictors.
   
  write_formula <- function(outcome = dicotom_var) {
    as.formula(paste(outcome, " ~ ", paste(balancing_variables, collapse = " + "))) 
  } 

   
  # Write corresponding formula that will be used with 'matchit'
  # Different formulas depending on what the effect_variable is
  if        (effect_variable == "openPrison") {
    dichotom_var <- "open01"
    matching_formula <- write_formula("open01")
    
  } else if (effect_variable == "conditionalReleaseGranted") {
    dichotom_var <- "cond01"
    matching_formula <- write_formula("cond01")

  } else {
    warning("Could not determine effect")
  }
  
  
 # Do matching with prespecified parameters
   
   # Exclude irrelevant variables with missing values. 
   # Matchit does not allow missing values. 
   # All included predictors are complete data. Matchit will not run if a
      # used predictor is excluded.
   
   index_no_missing <- apply(included_sample, MARGIN = 2, FUN = anyNA) == FALSE
   no_missing_vars <- names(included_sample)[index_no_missing]
  
  out$match <- matchit(formula = matching_formula,
                       data    = subset_data[no_missing_vars], 
                       method  = "nearest", discard = "both",
                       distance = "logit", caliper = 0.25, ratio = 1)
  
  # Add the calculated distance measure to the data frame
  out$data$distance_prob  <- out$match$distance
  # Calculate logit for this that can be used in the logistic regression
  out$data$distance_logit <- log(out$match$distance / (1 - out$match$distance))
  
  out$data$matched <- out$match$weights
  out$data$matched_f <- factor(out$data$matched, levels = c(1,0), 
                             labels = c("Matched", "Unmatched"))
    
  # Function to get category
  # Right now this is not needed (2018-02-19)
  get_category <- function(match_variable, effect_variable){
    m <- match_variable
    e <- effect_variable
    ifelse                      (m == 1 & e == 0, "matched_0",
            ifelse              (m == 1 & e == 1, "matched_1", 
                   ifelse       (m == 0 & e == 0, "unmatched_0",
                          ifelse(m == 0 & e == 1, "unmatched_1",
                                 NA))))
  }
   
  # Add a category variable   
  out$data$category <- get_category(match_variable  = out$data$matched,
                                    effect_variable = out$data[[dichotom_var]])

  return(out)
}



```


# Do the matching for each subset.

```{r}
op_cr0_ps0 <-  my_matching(subset_cr0_ps0, "openPrison")
op_cr0_ps1 <-  my_matching(subset_cr0_ps1, "openPrison")
 
cr_op1_ps0 <-  my_matching(subset_op1_ps0, "conditionalReleaseGranted")
cr_op1_ps1 <-  my_matching(subset_op1_ps1, "conditionalReleaseGranted")
  
```

Checks
```{r}
do_checks_I_want <- function(my_matching_output) {
  
  matchit_object <- my_matching_output$match
  matchit_object
  plot(matchit_object, type = "jitter")
  plot(summary(matchit_object, standardize = TRUE))
}
```

```{r}
do_checks_I_want(op_cr0_ps0)
```

```{r}
do_checks_I_want(op_cr0_ps1)
```

```{r}
do_checks_I_want(cr_op1_ps0)
```

```{r}
do_checks_I_want(cr_op1_ps1)
```

# Logistic regression analyses

In this part of the analyses we do the logistic regression analyses and plot the results.

## Function for logistic regressions

Here we write a function that takes the list of results previously compiled (data and matching results) and adds logistic regression results. We perform two logistic regression analyses:
1. An ancova style analysis with the effect of the independent variable controlled by the propensity score
2. Extending this with an interaction effect to test the assumption of "parallel lines".

Estimated probabilities from 2) will be used in the plots. 

```{r}

add_glm_tests <- function(results_list) {
  if (results_list$effect_variable == "openPrison") {         # open placement
    f_ancova      <- "reoffenceThisTerm ~ openPrison + distance_logit"
    f_interaction <- "reoffenceThisTerm ~ openPrison * distance_logit"
    
  } else if (results_list$effect_variable == "conditionalReleaseGranted"){         # conditional release
    f_ancova      <- "reoffenceThisTerm ~ conditionalReleaseGranted + distance_logit"
    f_interaction <- "reoffenceThisTerm ~ conditionalReleaseGranted * distance_logit"
    
  } else {
    warning('Could not specificy effect')
  }
  
  used_data <- results_list$data[results_list$data$matched == 1, ]
  
  results_list$glm_ancova      <- glm(f_ancova,      
                                          family = binomial, data = used_data)
  results_list$glm_interaction <- glm(f_interaction, 
                                          family = binomial, data = used_data)

  return(results_list)
}


```

Use this function on the results lists.

```{r}
op_cr0_ps0 <- add_glm_tests(op_cr0_ps0)
op_cr0_ps1 <- add_glm_tests(op_cr0_ps1)

cr_op1_ps0 <- add_glm_tests(cr_op1_ps0)
cr_op1_ps1 <- add_glm_tests(cr_op1_ps1)

```

Write a function to get the chi-square value for the models and associated p-values

```{r}
get_chi_stats <- function(glm_model) {
  d_chisq = glm_model$null.deviance - glm_model$deviance
  d_df    = glm_model$df.null       - glm_model$df.residual
  p       = 1 - pchisq(q = d_chisq, df = d_df)
  data_frame(d_chisq, d_df, p)
}
```


Results for the effect of placement in open prison
- in combination with no conditional release
- among individuals NOT SUPERVISED during parole

No main effect. Adding interaction term is not a statistically significant improvement.

```{r}
summary      (op_cr0_ps0$glm_ancova)
get_chi_stats(op_cr0_ps0$glm_ancova)

summary      (op_cr0_ps0$glm_interaction)
get_chi_stats(op_cr0_ps0$glm_interaction)

anova(op_cr0_ps0$glm_ancova, op_cr0_ps0$glm_interaction, test = "Chisq")

```
# Plots

Write a function to plot interesting results

```{r}
make_graph <- function (results_list, ind_variable, 
                        in_comb_with = NA) {



if          (ind_variable == "openPrison") {
  title         =  "Effect of placement"
  legend_name   =  "Placement"
  legend_breaks =  c("open_prison", "closed_prison")
  legend_labels =  c("Open Prison", "Closed Prison")
  propens_score = "distance_logit"

} else if (ind_variable == "conditionalReleaseGranted") {
  title         =  "Effect of conditional release (CR)"
  legend_name   =  "CR Status"
  legend_breaks =  c("cr_granted", "cr_not_granted")
  legend_labels =  c("Successful CR", "No CR")
  propens_score = "distance_logit"

} else {
    warning("Could not find effect")
}
  
tick_breaks <-  c(0, 0.25, 0.5, 0.75, 1)
tick_labels <-  c("0", "", ".5", "", "1" )   

subtitle    <- paste("In combination with" , in_comb_with)
                          
plot_data <- data.frame(
  propensity_score    = results_list$data[[propens_score]],
  est_prob_recidivism = predict(results_list$glm_interaction, 
                                type = "response", newdata = results_list$data),
  ind_variable        = results_list$data[[ind_variable]],
  matched_f           = results_list$data[["matched_f"]]
) 


# A better alternative to the line plot might be to just draw the line generated from regression
                          # coefficients and limit to the max and min propensities
                          

# For the upper line plot only include matched individuals 



# Create the line plot
line_plot <- 
  plot_data %>% 
  filter(matched_f == "Matched") %>% 
  ggplot(aes(x = propensity_score, 
             y = est_prob_recidivism, 
             col = ind_variable)) + 
  geom_line() +
  ggtitle(title, subtitle = subtitle) +
  xlab(NULL) + 
  ylab("Est. probability of recidivism") +
  scale_x_continuous(limits = c(0,1), breaks = tick_breaks, labels = tick_labels) +
  scale_y_continuous(limits = c(0,1), breaks = tick_breaks, labels = tick_labels) +
  scale_color_discrete(name = legend_name,
                       breaks = legend_breaks,
                       labels = legend_labels) +
  theme_tufte(base_family = "sans") +
  theme(legend.position = c(0.9, 0.9))
  
  

# Create the bottom jitter plot
jitter_plot <- plot_data %>% 
  ggplot(aes(x = propensity_score,
             y = ind_variable,
             col = ind_variable)) +
  geom_jitter() +
  xlab("Propensity score") +
  ylab("Matching category") +
  scale_x_continuous(limits = c(0,1), breaks = tick_breaks, labels = tick_labels) +
  scale_y_discrete(breaks = NULL) +
  theme_tufte(base_family = "sans") +
  theme(legend.position = "none") + 
  facet_grid(matched_f ~ .) 
  
  
# Translate ggplot objects to grobs         

line_grob <- ggplotGrob(line_plot)
jitter_grob <- ggplotGrob(jitter_plot)

# Determine the size of the three leftmost areas according to the needs of the line_plot
jitter_grob$widths[1:3] <- line_grob$widths[1:3]
# Now set the number of column areas and their widths to be that of the jitter grob
line_grob$widths <- jitter_grob$widths

# Arrange the two grobs in two rows, with the first row being propostionally bigger.
grid.arrange(line_grob, jitter_grob, nrow = 2, heights = c(1.3,1))
}

```

Make the actual grafs

```{r}

g_o1 <-
make_graph(op_cr0_ps0, "openPrison",
           "no conditional release and no supervision of parole")
g_o2 <- 
make_graph(op_cr0_ps1, "openPrison", 
           "no conditional release but with supervision of parole")

g_c1 <-
make_graph(cr_op1_ps0, "conditionalReleaseGranted",
           "open prison and no supervision of parole")
g_c2 <- 
make_graph(cr_op1_ps1, "conditionalReleaseGranted",
           "open prison and supervision of parole")

```