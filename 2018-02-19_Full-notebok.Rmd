---
title: "Analyses for 'The practices of open prison and conditional release and their relation to recidivism rates'"
output:
  github_document:
    toc: true

---

# Setup

Load needed packages

```{r}
library(tidyverse)
library(stringr)
library(MatchIt)
library(ggthemes)
library(gridExtra)
sessionInfo()
```

# Data - Load and subset

Import dataset 'FinPrisonMales'. This version of the data includes only males. Data is not publicly available. Check https://osf.io/e9dzf/ for a description of the data, including inclusion and exclusion criteria and summary statistics. (This description will be uploaded at a later date - it is not yet available as of 2018-02-19.)

```{r}
rm(list = ls())
FinPrisonMales <- 
  readRDS("C:/Users/benny_000/Dropbox/AAAKTUELLT/FinPrisonData/FinPrisonMales.rds")
```


Exclude individuals who comitted a crime during the sentence. This is the simplest way to handle the issue that we do not know when the crime was committed, when it was uncovered, or how it affected placement decisions.


These are 93 individuals
```{r}
table(FinPrisonMales$crimeDuringSentence)
```


```{r}
included_sample <-
  FinPrisonMales %>% 
  filter(crimeDuringSentence == "No records of crime")

rm(FinPrisonMales)
```


Also, exclude individuals with suspended conditional release. This is the easiest way to handle the confounding that individuals granted conditional release from open prison may have been placed in closed prison if the conditional release was revoked.

This is the distribution of individuals over status of placement at release and conditional release:

```{r}
table(included_sample$openPrison, included_sample$conditionalReleaseOutcome)
```


```{r}
included_sample <-
  included_sample %>% 
  filter(conditionalReleaseOutcome != "Cancelled conditional release")

```

This leaves us with the following breakdown of individuals.
```{r}
table(included_sample$openPrison, included_sample$conditionalReleaseOutcome)
```

Further we seperate those with their parole supervised and those without supervision.

```{r}
table(included_sample$supervisedParole, included_sample$conditionalReleaseOutcome, included_sample$openPrison)
```

The smallest groups (individuals placed in closed prison and not granted conditional release) will not be examined further. That leaves us with the possiblity to examine 
- the effect of placement among those not granted conditional release
- the effect of conditional release among those placed in open prison at the end of their sentence.


# Create subgroups


Key for abbreviations:

op = Open Placement
cr = Conditional Release
ps = Parole Supervised

0 = no, 1 = yes


```{r}
# Subgroups for examining effect of open prison
subset_cr0_ps0<-
  included_sample %>% 
  filter(conditionalReleaseGranted == "cr_not_granted" & supervisedParole == "no supervision")

subset_cr0_ps1 <-
  included_sample %>% 
  filter(conditionalReleaseGranted == "cr_not_granted" & supervisedParole == "supervised parole")

# Subgroups for examining effect of conditional relase
subset_op1_ps0  <-
  included_sample %>% 
  filter(openPrison == "open_prison" & supervisedParole == "no supervision")

subset_op1_ps1 <- 
  included_sample %>% 
  filter(openPrison == "open_prison" & supervisedParole == "supervised parole")


```



# Matching

## Define sets of predictors

The vector `all_predictors` will be used to write the formula for propensity scores.
```{r}
offence_variables <- 
  str_subset(names(included_sample), "^o_")

static_preds <- 
   c("ageFirstSentence_mr", "ageFirst_missing", "ageAtRelease", 
     "ps_escapeHistory", "ps_prisonTerms_mr", "ps_comServiceTerms_mr", 
     "ps_remandTerms_mr", "ps_defaultTerms_mr", "ps_info_missing", 
     offence_variables)


rita_factors <- 
   c("economy_problems", "alcohol_problems", "resistance_change", 
     "drug_related_probl", "aggressiveness", "employment_probl") 


all_predictors <- c(static_preds, rita_factors)

```




## Matching function

Write a function for matching. This function takes the following arguments:
+ 'subset_data' - A data frame. The subset previously generated that only includes individuals who have gotten the same treatment except for the effect variable. 
+ 'effect_variable' - A character string. The name of the variable that constitutes the independent variable in later analysis. The matching should thus produce two groups that are blananced on every covariate except this variable.
+ 'blancing_variables' - A vector of character stings. The names of all the variables that serve as covariates. The default is a previously defined vector 'all_predictors'.


```{r}

my_matching <- function(subset_data, effect_variable, balancing_variables = all_predictors, ...) {
  require(MatchIt)
  
  # Intitate a list of results that will be returned
   out <- list(effect_variable = effect_variable, data = subset_data, match = NA)

  # Write the formulas that will be needed
  # Matching formulas. Here the other exactly matched variables are not included as predictors.
   
   
  write_formula <- function(dicotom_outcome) {
    as.formula(paste(dicotom_outcome, " ~ ", paste(balancing_variables, collapse = " + "))) 
  } 

  # Write corresponding formula that will be used with 'matchit'
  # matchit needs dichotomous outcomes - create those here 
  # Different formulas depending on what the effect_variable is
  if        (effect_variable == "openPrison") {
    subset_data$open01 <- as.numeric(subset_data$openPrison) - 1
    matching_formula   <- write_formula("open01")
    
  } else if (effect_variable == "conditionalReleaseGranted") {
    subset_data$cond01 <- as.numeric(subset_data$conditionalReleaseGranted) - 1
    matching_formula   <- write_formula("cond01")

  } else {
    warning("Could not determine effect")
  }
  
  
 # Do matching with prespecified parameters
   
   # Exclude irrelevant variables with missing values. 
   # Matchit does not allow missing values. 
   # All included predictors are complete data. Matchit will not run if a
      # used predictor is excluded.
   
  index_no_missing <- apply(subset_data, MARGIN = 2, FUN = anyNA) == FALSE
  no_missing_vars <- names(subset_data)[index_no_missing]
  
  out$match <- matchit(formula = matching_formula,
                       data    = subset_data[no_missing_vars], 
                       method  = "nearest", discard = "both",
                       distance = "logit", caliper = 0.25, ratio = 1)
  
  # Add the calculated distance measure to the data frame
  out$data$distance_prob  <- out$match$distance
  # Calculate logit for this that can be used in the logistic regression
  out$data$distance_logit <- log(out$match$distance / (1 - out$match$distance))
  
  out$data$matched <- out$match$weights
  out$data$matched_f <- factor(out$data$matched, levels = c(1,0), 
                             labels = c("Matched", "Unmatched"))

  return(out)
}



```


## Do the matching for each subset.

```{r}
op_cr0_ps0 <-  my_matching(subset_cr0_ps0, "openPrison")
op_cr0_ps1 <-  my_matching(subset_cr0_ps1, "openPrison")
 
cr_op1_ps0 <-  my_matching(subset_op1_ps0, "conditionalReleaseGranted")
cr_op1_ps1 <-  my_matching(subset_op1_ps1, "conditionalReleaseGranted")
  
```

## Checks
```{r}
do_checks_I_want <- function(my_matching_output) {
  
  matchit_object <- my_matching_output$match
  matchit_object
  plot(matchit_object, type = "jitter")
  plot(summary(matchit_object, standardize = TRUE))
}
```

```{r}
do_checks_I_want(op_cr0_ps0)
```

```{r}
do_checks_I_want(op_cr0_ps1)
```

```{r}
do_checks_I_want(cr_op1_ps0)
```

```{r}
do_checks_I_want(cr_op1_ps1)
```

# Logistic regression analyses

In this part of the analyses we do the logistic regression analyses.

## Function for logistic regressions

Here we write a function that takes the list of results previously compiled (data and matching results) and adds logistic regression results. We perform two logistic regression analyses:
1. An ancova style analysis with the effect of the independent variable controlled by the propensity score
2. Extending this with an interaction effect to test the assumption of "parallel lines".

Estimated probabilities from 2) will be used in the plots. 

```{r}

add_glm_tests <- function(results_list) {
  if (results_list$effect_variable == "openPrison") {         # open placement
    f_ancova      <- "reoffenceThisTerm ~ openPrison + distance_logit"
    f_interaction <- "reoffenceThisTerm ~ openPrison * distance_logit"
    
  } else if (results_list$effect_variable == "conditionalReleaseGranted"){         # conditional release
    f_ancova      <- "reoffenceThisTerm ~ conditionalReleaseGranted + distance_logit"
    f_interaction <- "reoffenceThisTerm ~ conditionalReleaseGranted * distance_logit"
    
  } else {
    warning('Could not specificy effect')
  }
  
  used_data <- results_list$data[results_list$data$matched == 1, ]
  
  results_list$glm_ancova      <- glm(f_ancova,      
                                          family = binomial, data = used_data)
  results_list$glm_interaction <- glm(f_interaction, 
                                          family = binomial, data = used_data)

  return(results_list)
}


```

Write a function to get the chi-square value for the models and associated p-values

```{r}
get_chi_stats <- function(glm_model) {
  d_chisq = glm_model$null.deviance - glm_model$deviance
  d_df    = glm_model$df.null       - glm_model$df.residual
  p       = 1 - pchisq(q = d_chisq, df = d_df)
  data_frame(d_chisq, d_df, p)
}
```



## Run analyses

Use this function on the results lists.

```{r}
op_cr0_ps0 <- add_glm_tests(op_cr0_ps0)
op_cr0_ps1 <- add_glm_tests(op_cr0_ps1)

cr_op1_ps0 <- add_glm_tests(cr_op1_ps0)
cr_op1_ps1 <- add_glm_tests(cr_op1_ps1)

```

## Results

### Effect: Open Prison. Subset: NOT Supervised 

Results for the effect of placement in open prison
- in combination with no conditional release
- among individuals NOT SUPERVISED during parole

No main effect. Adding interaction term is not a statistically significant improvement.

```{r}
summary      (op_cr0_ps0$glm_ancova)
get_chi_stats(op_cr0_ps0$glm_ancova)

summary      (op_cr0_ps0$glm_interaction)
get_chi_stats(op_cr0_ps0$glm_interaction)

anova(op_cr0_ps0$glm_ancova, op_cr0_ps0$glm_interaction, test = "Chisq")

```
### Effect: Open Prison. Subset: Supervised 

Results for the effect of placement in open prison
- in combination with no conditional release
- among individuals SUPERVISED during parole

No main effect. Adding interaction term is not a statistically significant improvement.

```{r}
summary      (op_cr0_ps1$glm_ancova)
get_chi_stats(op_cr0_ps1$glm_ancova)

summary      (op_cr0_ps1$glm_interaction)
get_chi_stats(op_cr0_ps1$glm_interaction)

anova(op_cr0_ps1$glm_ancova, op_cr0_ps1$glm_interaction, test = "Chisq")

```

### Effect: CR. Subset: NOT Supervised 

Results for the effect of conditional release
- in combination with placement in open prison
- among individuals NOT SUPERVISED during parole

No main effect. Adding interaction term is not a statistically significant improvement.

```{r}
summary      (cr_op1_ps0$glm_ancova)
get_chi_stats(cr_op1_ps0$glm_ancova)

summary      (cr_op1_ps0$glm_interaction)
get_chi_stats(cr_op1_ps0$glm_interaction)

anova(cr_op1_ps0$glm_ancova, cr_op1_ps0$glm_interaction, test = "Chisq")

```
### Effect: CR. Subset: Supervised 

Results for the effect of conditional release
- in combination with placement in open prison
- among individuals SUPERVISED during parole

No main effect. Adding interaction term is not a statistically significant improvement.

```{r}
summary      (cr_op1_ps1$glm_ancova)
get_chi_stats(cr_op1_ps1$glm_ancova)

summary      (cr_op1_ps1$glm_interaction)
get_chi_stats(cr_op1_ps1$glm_interaction)

anova(cr_op1_ps1$glm_ancova, cr_op1_ps1$glm_interaction, test = "Chisq")

```



# Plots

Write a function to plot interesting results

```{r}
make_graph <- function (results_list, ind_variable, 
                        my_x_lab = NULL, y_labels = FALSE,
                        facet_labels = FALSE, legend = FALSE) {



if          (ind_variable == "openPrison") {
  title         =  "Effect of placement"
  legend_name   =  "Placement"
  legend_breaks =  c("open_prison", "closed_prison")
  legend_labels =  c("Open Prison", "Closed Prison")
  propens_score = "distance_prob"

} else if (ind_variable == "conditionalReleaseGranted") {
  title         =  "Effect of conditional release (CR)"
  legend_name   =  "CR Status"
  legend_breaks =  c("cr_granted", "cr_not_granted")
  legend_labels =  c("Successful CR", "No CR")
  propens_score = "distance_prob"

} else {
    warning("Could not find effect")
}
  
tick_breaks <-  c(0, 0.25, 0.5, 0.75, 1)
tick_labels <-  c("0", "", ".5", "", "1" )   

# subtitle    <- paste("In combination with" , in_comb_with)
                          
plot_data <- data.frame(
  propensity_score    = results_list$data[[propens_score]],
  est_prob_recidivism = predict(results_list$glm_interaction, 
                                type = "response", newdata = results_list$data),
  ind_variable        = results_list$data[[ind_variable]],
  matched_f           = results_list$data[["matched_f"]]
) 


if (y_labels == TRUE) {
  my_y_lab_line   <- "Est. prob. of recidivism"
  my_y_lab_jitter <- "Match category" 
} else {
  my_y_lab_line   <- NULL
  my_y_lab_jitter <- NULL 
}

if (y_labels == TRUE) {
  my_y_lab_line   <- "Est. prob. of recidivism"
  my_y_lab_jitter <- "Match category" 
} else {
  my_y_lab_line   <- NULL
  my_y_lab_jitter <- NULL 
}


if (facet_labels == TRUE) {
  my_strip_text <- element_text()
} else {
  my_strip_text <- element_blank()
}

if (legend == TRUE) {
  legend_pos <- theme(legend.position = c(0.8, 0.8))
} else {
  legend_pos <- theme(legend.position = "none")
}



# A better alternative to the line plot might be to just draw the line generated from regression
                          # coefficients and limit to the max and min propensities
                          

# For the upper line plot only include matched individuals 

# Create the line plot
line_plot <- 
  plot_data %>% 
  filter(matched_f == "Matched") %>% 
  ggplot(aes(x = propensity_score, 
             y = est_prob_recidivism, 
             col = ind_variable)) + 
  geom_line() +
  # ggtitle(title, subtitle = subtitle) +
  xlab(NULL) + 
  ylab(my_y_lab_line) +
  scale_x_continuous(limits = c(0,1), breaks = tick_breaks, labels = NULL) +
  scale_y_continuous(limits = c(0,1), breaks = tick_breaks, labels = tick_labels) +
  scale_color_discrete(name = legend_name,
                       breaks = legend_breaks,
                       labels = legend_labels) +
  theme_tufte(base_family = "sans") +
  legend_pos
  
  

# Create the bottom jitter plot
jitter_plot <- plot_data %>% 
  ggplot(aes(x = propensity_score,
             y = ind_variable,
             col = ind_variable)) +
  geom_jitter(alpha = 0.3) +
  xlab(my_x_lab) +
  ylab(my_y_lab_jitter) +
  scale_x_continuous(limits = c(0,1), breaks = tick_breaks, labels = tick_labels) +
  scale_y_discrete(breaks = NULL) +
  theme_tufte(base_family = "sans") +
  theme(legend.position = "none", strip.text.y = my_strip_text) + 
  facet_grid(matched_f ~ .) 
  
  
# Translate ggplot objects to grobs         

line_grob <- ggplotGrob(line_plot)
jitter_grob <- ggplotGrob(jitter_plot)

# Determine the size of the three leftmost areas according to the needs of the line_plot
jitter_grob$widths[1:3] <- line_grob$widths[1:3]
# Now set the number of column areas and their widths to be that of the jitter grob
line_grob$widths <- jitter_grob$widths

# Arrange the two grobs in two rows, with the first row being propostionally bigger.
grid.arrange(line_grob, jitter_grob, nrow = 2, heights = c(1.3,1))
}

```

Make the actual grafs

```{r}

g_open_no_superv<-
make_graph(op_cr0_ps0, "openPrison", 
           y_labels = TRUE,
           legend = TRUE)

g_open_superv <- 
make_graph(op_cr0_ps1, "openPrison", 
           my_x_lab = "Propensity for open prison",
           y_labels = TRUE)

g_cond_no_superv <-
make_graph(cr_op1_ps0, "conditionalReleaseGranted",
           facet_labels = TRUE,
           legend = TRUE)

g_cond_superv <- 
make_graph(cr_op1_ps1, "conditionalReleaseGranted",
           facet_labels = TRUE,
           my_x_lab = "Propensity for CR")

```


Combine grobs
```{r fig.height=8.69, fig.width=6.27}
grid.arrange(grobs = list(g_open_no_superv, g_cond_no_superv, 
                          g_open_superv,    g_cond_superv), 
             nrow = 2, ncol = 2)
```

